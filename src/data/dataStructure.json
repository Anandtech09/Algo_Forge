[
  {
    "id": "array",
    "name": "Array",
    "description": "A collection of elements stored at contiguous memory locations",
    "complexity": { "time": "O(1) access", "space": "O(n)" },
    "applications": ["Data storage", "Matrix operations", "Dynamic programming"],
    "difficulty": "Beginner",
    "category": "Arrays",
    "youtubeUrl": "https://www.youtube.com/watch?v=QJNwK2uJyGs",
    "explanation": "An array is a fundamental data structure that stores elements of the same type in contiguous memory locations. Each element can be accessed directly using its index, making it very efficient for random access operations.\n\nKey characteristics:\n• Fixed size (in most implementations)\n• Elements are stored consecutively in memory\n• Index-based access with O(1) time complexity\n• Cache-friendly due to spatial locality\n\nArrays are the building blocks for many other data structures and are essential for understanding computer science fundamentals.",
    "pythonCode": "# Array operations in Python (using lists)\ndef array_operations():\n    # Creating an array\n    arr = [1, 2, 3, 4, 5]\n    \n    # Accessing elements - O(1)\n    first_element = arr[0]\n    last_element = arr[-1]\n    \n    # Modifying elements - O(1)\n    arr[2] = 10\n    \n    # Length of array - O(1)\n    length = len(arr)\n    \n    # Searching - O(n)\n    def linear_search(arr, target):\n        for i in range(len(arr)):\n            if arr[i] == target:\n                return i\n        return -1\n    \n    # Example usage\n    print(f\"Array: {arr}\")\n    print(f\"Length: {length}\")\n    print(f\"Search for 10: {linear_search(arr, 10)}\")\n\narray_operations()"
  },
  {
    "id": "dynamic-array",
    "name": "Dynamic Array",
    "description": "Resizable array that can grow or shrink during runtime",
    "complexity": { "time": "O(1) amortized", "space": "O(n)" },
    "applications": ["ArrayList", "Vector", "Flexible data storage"],
    "difficulty": "Beginner",
    "category": "Arrays",
    "youtubeUrl": "https://www.youtube.com/watch?v=PEnFFiQe1pM",
    "explanation": "A dynamic array is an array that can resize itself automatically when elements are added or removed. It provides the flexibility of arrays with the ability to grow or shrink as needed.\n\nKey characteristics:\n• Resizable array with amortized O(1) append\n• Internally uses a fixed-size array and resizes when full\n• Provides random access like static arrays\n• Commonly used in high-level languages as list or vector\n\nDynamic arrays are widely used in applications requiring flexible and efficient storage.",
    "pythonCode": "# Python list is a dynamic array\ndef dynamic_array_example():\n    arr = []\n    for i in range(5):\n        arr.append(i)\n    \n    print(\"Dynamic array contents:\", arr)\n    arr.pop()\n    print(\"After pop:\", arr)\n\ndynamic_array_example()"
  },
  {
    "id": "multi-dimensional-array",
    "name": "Multi-dimensional Array",
    "description": "Arrays with more than one dimension for matrix-like data",
    "complexity": { "time": "O(1) access", "space": "O(n²)" },
    "applications": ["Matrix operations", "Image processing", "Game boards"],
    "difficulty": "Intermediate",
    "category": "Arrays",
    "youtubeUrl": "https://www.youtube.com/watch?v=jzJlq35dAqY",
    "explanation": "Multi-dimensional arrays are arrays of arrays, allowing storage of data in multiple dimensions such as 2D or 3D. They are essential for representing matrices, grids, and spatial data.\n\nKey characteristics:\n• Indexed by multiple indices (e.g., row and column)\n• Used in mathematical computations and graphics\n• Access time remains O(1) for each element\n• Memory layout can be row-major or column-major\n\nThey are fundamental in scientific computing and graphics programming.",
    "pythonCode": "# 2D array example in Python\ndef multi_dimensional_array():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    \n    # Access element at row 1, column 2\n    print(\"Element at (1,2):\", matrix[1][2])\n    \n    # Iterate over rows and columns\n    for row in matrix:\n        for val in row:\n            print(val, end=' ')\n        print()\n\nmulti_dimensional_array()"
  },
  {
    "id": "linked-list",
    "name": "Singly Linked List",
    "description": "Linear data structure where elements point to the next element",
    "complexity": { "time": "O(n) search", "space": "O(n)" },
    "applications": ["Dynamic memory allocation", "Undo functionality", "Music playlists"],
    "difficulty": "Beginner",
    "category": "Linked Lists",
    "youtubeUrl": "https://www.youtube.com/watch?v=WwfhLC16bis",
    "explanation": "A singly linked list is a linear data structure where each element (node) contains data and a reference to the next node in the sequence. It allows efficient insertion and deletion.\n\nKey characteristics:\n• Nodes contain data and pointer to next node\n• No direct access by index; traversal required\n• Dynamic size, efficient insertions/deletions\n• Used in stacks, queues, and dynamic memory management\n\nSingly linked lists are foundational for understanding pointers and dynamic data structures.",
    "pythonCode": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass SinglyLinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n    \n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=' -> ')\n            current = current.next\n        print('None')\n\n# Example usage\nsll = SinglyLinkedList()\nsll.append(1)\nsll.append(2)\nsll.append(3)\nsll.print_list()"
  },
  {
    "id": "doubly-linked-list",
    "name": "Doubly Linked List",
    "description": "Linked list with pointers to both next and previous elements",
    "complexity": { "time": "O(n) search", "space": "O(n)" },
    "applications": ["Browser history", "LRU cache", "Navigation systems"],
    "difficulty": "Intermediate",
    "category": "Linked Lists",
    "youtubeUrl": "https://www.youtube.com/watch?v=k0pjD12bzP0",
    "explanation": "A doubly linked list is a linked list where each node contains references to both the next and previous nodes, allowing bidirectional traversal.\n\nKey characteristics:\n• Nodes have pointers to next and previous nodes\n• Supports efficient insertions and deletions from both ends\n• Enables reverse traversal\n• Used in complex data structures like LRU caches\n\nDoubly linked lists provide more flexibility than singly linked lists at the cost of extra memory.",
    "pythonCode": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n        new_node.prev = last\n    \n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=' <-> ')\n            current = current.next\n        print('None')\n\n# Example usage\ndll = DoublyLinkedList()\ndll.append(1)\ndll.append(2)\ndll.append(3)\ndll.print_list()"
  },
  {
    "id": "circular-linked-list",
    "name": "Circular Linked List",
    "description": "Linked list where the last element points back to the first",
    "complexity": { "time": "O(n) search", "space": "O(n)" },
    "applications": ["Round-robin scheduling", "Circular queues", "Game turn systems"],
    "difficulty": "Intermediate",
    "category": "Linked Lists",
    "youtubeUrl": "https://www.youtube.com/watch?v=5WoNhm7sOnA",
    "explanation": "A circular linked list is a linked list where the last node points back to the first node, forming a circle. It can be singly or doubly linked.\n\nKey characteristics:\n• Last node points to the head node\n• Useful for cyclic processes and buffering\n• Supports continuous traversal without null checks\n• Used in scheduling and multiplayer games\n\nCircular linked lists provide efficient looping over data without explicit resets.",
    "pythonCode": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            new_node.next = self.head\n            return\n        current = self.head\n        while current.next != self.head:\n            current = current.next\n        current.next = new_node\n        new_node.next = self.head\n    \n    def print_list(self):\n        current = self.head\n        if not current:\n            return\n        while True:\n            print(current.data, end=' -> ')\n            current = current.next\n            if current == self.head:\n                break\n        print('(head)')\n\n# Example usage\ncll = CircularLinkedList()\ncll.append(1)\ncll.append(2)\ncll.append(3)\ncll.print_list()"
  },
  {
    "id": "stack",
    "name": "Stack",
    "description": "LIFO (Last In, First Out) data structure",
    "complexity": { "time": "O(1) operations", "space": "O(n)" },
    "applications": ["Function calls", "Expression evaluation", "Undo operations"],
    "difficulty": "Beginner",
    "category": "Stacks",
    "youtubeUrl": "https://www.youtube.com/watch?v=F1F2imiOJfk",
    "explanation": "A stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Elements are added and removed from the top of the stack.\n\nKey characteristics:\n• Push and pop operations at the top\n• Supports backtracking and undo functionality\n• Used in function call management and expression evaluation\n• Simple and efficient with O(1) operations\n\nStacks are fundamental in many algorithms and system designs.",
    "pythonCode": "class Stack:\n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        self.items.append(item)\n    \n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n        return None\n    \n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n        return None\n    \n    def is_empty(self):\n        return len(self.items) == 0\n\n# Example usage\nstack = Stack()\nstack.push(1)\nstack.push(2)\nprint(stack.pop())  # Outputs 2\nprint(stack.peek()) # Outputs 1"
  },
  {
    "id": "min-stack",
    "name": "Min Stack",
    "description": "Stack that supports retrieving minimum element in O(1) time",
    "complexity": { "time": "O(1) all ops", "space": "O(n)" },
    "applications": ["Algorithm optimization", "Min/max tracking", "Stock span problems"],
    "difficulty": "Intermediate",
    "category": "Stacks",
    "youtubeUrl": "https://www.youtube.com/watch?v=qkLl7nAwDPo",
    "explanation": "A min stack is a stack that supports push, pop, and retrieving the minimum element in constant time. It maintains an auxiliary stack to track minimums.\n\nKey characteristics:\n• Push, pop, and getMin in O(1) time\n• Uses extra space to track minimums\n• Useful in optimization problems and tracking min/max values\n• Extends basic stack functionality\n\nMin stacks are important in algorithmic challenges and real-time data processing.",
    "pythonCode": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self):\n        if self.stack:\n            val = self.stack.pop()\n            if val == self.min_stack[-1]:\n                self.min_stack.pop()\n            return val\n        return None\n    \n    def get_min(self):\n        if self.min_stack:\n            return self.min_stack[-1]\n        return None\n\n# Example usage\nmin_stack = MinStack()\nmin_stack.push(3)\nmin_stack.push(5)\nmin_stack.push(2)\nprint(min_stack.get_min())  # Outputs 2\nmin_stack.pop()\nprint(min_stack.get_min())  # Outputs 3"
  },
  {
    "id": "queue",
    "name": "Queue",
    "description": "FIFO (First In, First Out) data structure",
    "complexity": { "time": "O(1) operations", "space": "O(n)" },
    "applications": ["Process scheduling", "BFS traversal", "Print queues"],
    "difficulty": "Beginner",
    "category": "Queues",
    "youtubeUrl": "https://www.youtube.com/watch?v=W0aE-w61Cb8",
    "explanation": "A queue is a linear data structure that follows the First In, First Out (FIFO) principle. Elements are added at the rear and removed from the front.\n\nKey characteristics:\n• Enqueue at rear, dequeue at front\n• Used in scheduling, buffering, and BFS\n• Supports sequential processing\n• Simple and efficient with O(1) operations\n\nQueues are essential in operating systems and network buffering.",
    "pythonCode": "from collections import deque\n\ndef queue_example():\n    queue = deque()\n    queue.append(1)  # Enqueue\n    queue.append(2)\n    print(queue.popleft())  # Dequeue, outputs 1\n    print(queue)  # Outputs deque([2])\n\nqueue_example()"
  },
  {
    "id": "circular-queue",
    "name": "Circular Queue",
    "description": "Queue where the last position connects back to the first",
    "complexity": { "time": "O(1) operations", "space": "O(n)" },
    "applications": ["Buffer management", "CPU scheduling", "Memory management"],
    "difficulty": "Intermediate",
    "category": "Queues",
    "youtubeUrl": "https://www.youtube.com/watch?v=dn01XST9-bI",
    "explanation": "A circular queue is a queue where the last position is connected back to the first position to make a circle. It efficiently uses space by reusing vacated slots.\n\nKey characteristics:\n• Fixed size buffer with wrap-around\n• Avoids shifting elements on dequeue\n• Used in buffering and resource scheduling\n• Requires careful management of front and rear pointers\n\nCircular queues optimize memory usage in fixed-size buffers.",
    "pythonCode": "class CircularQueue:\n    def __init__(self, size):\n        self.size = size\n        self.queue = [None] * size\n        self.front = self.rear = -1\n    \n    def enqueue(self, data):\n        if (self.rear + 1) % self.size == self.front:\n            print(\"Queue is full\")\n            return\n        if self.front == -1:\n            self.front = 0\n        self.rear = (self.rear + 1) % self.size\n        self.queue[self.rear] = data\n    \n    def dequeue(self):\n        if self.front == -1:\n            print(\"Queue is empty\")\n            return None\n        data = self.queue[self.front]\n        if self.front == self.rear:\n            self.front = self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.size\n        return data\n\n# Example usage\ncq = CircularQueue(3)\ncq.enqueue(1)\ncq.enqueue(2)\ncq.enqueue(3)  # Queue is full\nprint(cq.dequeue())  # Outputs 1\ncq.enqueue(3)\nprint(cq.dequeue())  # Outputs 2"
  },
  {
    "id": "priority-queue",
    "name": "Priority Queue",
    "description": "Queue where elements are served based on priority",
    "complexity": { "time": "O(log n) insert", "space": "O(n)" },
    "applications": ["Dijkstra algorithm", "Huffman coding", "Task scheduling"],
    "difficulty": "Intermediate",
    "category": "Queues",
    "youtubeUrl": "https://www.youtube.com/watch?v=wptevk0bshY",
    "explanation": "A priority queue is an abstract data type where each element has a priority, and elements are served based on priority rather than order of insertion.\n\nKey characteristics:\n• Higher priority elements served first\n• Implemented using heaps for efficiency\n• Used in shortest path algorithms and scheduling\n• Supports insert and extract-min/max operations\n\nPriority queues are fundamental in many algorithmic applications.",
    "pythonCode": "import heapq\n\ndef priority_queue_example():\n    pq = []\n    heapq.heappush(pq, (2, 'code'))\n    heapq.heappush(pq, (1, 'eat'))\n    heapq.heappush(pq, (3, 'sleep'))\n    \n    while pq:\n        priority, task = heapq.heappop(pq)\n        print(task)\n\npriority_queue_example()"
  },
  {
    "id": "deque",
    "name": "Double-ended Queue (Deque)",
    "description": "Queue that allows insertion and deletion at both ends",
    "complexity": { "time": "O(1) operations", "space": "O(n)" },
    "applications": ["Sliding window problems", "Palindrome checking", "Web browsers"],
    "difficulty": "Intermediate",
    "category": "Queues",
    "youtubeUrl": "https://www.youtube.com/watch?v=5VDQxLAlfu0",
    "explanation": "A deque (double-ended queue) is a generalized queue that allows insertion and deletion at both the front and rear ends.\n\nKey characteristics:\n• Supports enqueue and dequeue at both ends\n• Can be used as stack or queue\n• Efficient for sliding window and palindrome problems\n• Implemented using doubly linked lists or circular buffers\n\nDeques provide flexible data access patterns for various algorithms.",
    "pythonCode": "from collections import deque\n\ndef deque_example():\n    d = deque()\n    d.append(1)      # Add to right\n    d.appendleft(2)  # Add to left\n    print(d)         # Outputs deque([2, 1])\n    d.pop()          # Remove from right\n    d.popleft()      # Remove from left\n    print(d)         # Outputs deque([])\n\ndeque_example()"
  },
  {
    "id": "binary-tree",
    "name": "Binary Tree",
    "description": "Tree where each node has at most two children",
    "complexity": { "time": "O(n) search", "space": "O(h)" },
    "applications": ["Expression parsing", "File systems", "Decision trees"],
    "difficulty": "Intermediate",
    "category": "Trees",
    "youtubeUrl": "https://www.youtube.com/watch?v=H5JubkIy_p8",
    "explanation": "A binary tree is a hierarchical data structure where each node has at most two children, referred to as left and right child. It's the foundation for many advanced tree structures.\n\nKey properties:\n• Each node has at most 2 children\n• Height determines performance characteristics\n• Various traversal methods (inorder, preorder, postorder)\n• Can represent hierarchical relationships\n\nBinary trees are used in many applications including expression evaluation, decision making, and as the basis for more complex tree structures.",
    "pythonCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n    \n    def insert(self, val):\n        if not self.root:\n            self.root = TreeNode(val)\n        else:\n            self._insert_recursive(self.root, val)\n    \n    def _insert_recursive(self, node, val):\n        if val < node.val:\n            if node.left is None:\n                node.left = TreeNode(val)\n            else:\n                self._insert_recursive(node.left, val)\n        else:\n            if node.right is None:\n                node.right = TreeNode(val)\n            else:\n                self._insert_recursive(node.right, val)\n    \n    def inorder_traversal(self, node, result=None):\n        if result is None:\n            result = []\n        if node:\n            self.inorder_traversal(node.left, result)\n            result.append(node.val)\n            self.inorder_traversal(node.right, result)\n        return result\n\n# Example usage\ntree = BinaryTree()\nvalues = [50, 30, 70, 20, 40, 60, 80]\nfor val in values:\n    tree.insert(val)\n\nprint(\"Inorder traversal:\", tree.inorder_traversal(tree.root))"
  },
  {
    "id": "binary-search-tree",
    "name": "Binary Search Tree",
    "description": "Binary tree with ordered nodes for efficient searching",
    "complexity": { "time": "O(log n) average", "space": "O(h)" },
    "applications": ["Database indexing", "Search operations", "Sorted data"],
    "difficulty": "Intermediate",
    "category": "Trees",
    "youtubeUrl": "https://www.youtube.com/watch?v=gcULXE7ViZw",
    "explanation": "A binary search tree (BST) is a binary tree where each node's left subtree contains values less than the node, and the right subtree contains values greater than the node.\n\nKey properties:\n• Left child < parent < right child\n• Enables efficient search, insertion, and deletion\n• Average time complexity O(log n)\n• Basis for many balanced tree structures\n\nBSTs are widely used in databases and search applications.",
    "pythonCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def insert(self, val):\n        self.root = self._insert(self.root, val)\n    \n    def _insert(self, node, val):\n        if not node:\n            return TreeNode(val)\n        if val < node.val:\n            node.left = self._insert(node.left, val)\n        else:\n            node.right = self._insert(node.right, val)\n        return node\n    \n    def search(self, val):\n        return self._search(self.root, val)\n    \n    def _search(self, node, val):\n        if not node or node.val == val:\n            return node\n        if val < node.val:\n            return self._search(node.left, val)\n        else:\n            return self._search(node.right, val)\n\n# Example usage\nbst = BST()\nbst.insert(50)\nbst.insert(30)\nbst.insert(70)\nfound = bst.search(30)\nprint(\"Found:\", found.val if found else \"Not found\")"
  },
  {
    "id": "avl-tree",
    "name": "AVL Tree",
    "description": "Self-balancing binary search tree",
    "complexity": { "time": "O(log n) guaranteed", "space": "O(n)" },
    "applications": ["Database systems", "Memory management", "Compiler design"],
    "difficulty": "Advanced",
    "category": "Trees",
    "youtubeUrl": "https://www.youtube.com/watch?v=jDM6_TnYIqE",
    "explanation": "An AVL tree is a self-balancing binary search tree where the heights of two child subtrees of any node differ by at most one. It maintains balance through rotations.\n\nKey properties:\n• Height-balanced BST\n• Guarantees O(log n) search, insert, delete\n• Uses rotations to maintain balance\n• Used in databases and memory management\n\nAVL trees ensure efficient operations by maintaining strict balance.",
    "pythonCode": "class AVLNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.height = 1\n\ndef get_height(node):\n    if not node:\n        return 0\n    return node.height\n\ndef get_balance(node):\n    if not node:\n        return 0\n    return get_height(node.left) - get_height(node.right)\n\ndef rotate_right(y):\n    x = y.left\n    T2 = x.right\n    \n    # Perform rotation\n    x.right = y\n    y.left = T2\n    \n    # Update heights\n    y.height = 1 + max(get_height(y.left), get_height(y.right))\n    x.height = 1 + max(get_height(x.left), get_height(x.right))\n    \n    return x\n\ndef rotate_left(x):\n    y = x.right\n    T2 = y.left\n    \n    # Perform rotation\n    y.left = x\n    x.right = T2\n    \n    # Update heights\n    x.height = 1 + max(get_height(x.left), get_height(x.right))\n    y.height = 1 + max(get_height(y.left), get_height(y.right))\n    \n    return y\n\ndef insert_avl(root, val):\n    # Step 1: Perform normal BST insertion\n    if not root:\n        return AVLNode(val)\n    \n    if val < root.val:\n        root.left = insert_avl(root.left, val)\n    else:\n        root.right = insert_avl(root.right, val)\n    \n    # Step 2: Update height\n    root.height = 1 + max(get_height(root.left), get_height(root.right))\n    \n    # Step 3: Get balance factor\n    balance = get_balance(root)\n    \n    # Step 4: Perform rotations if needed\n    # Left-Left case\n    if balance > 1 and val < root.left.val:\n        return rotate_right(root)\n    \n    # Right-Right case\n    if balance < -1 and val > root.right.val:\n        return rotate_left(root)\n    \n    # Left-Right case\n    if balance > 1 and val > root.left.val:\n        root.left = rotate_left(root.left)\n        return rotate_right(root)\n    \n    # Right-Left case\n    if balance < -1 and val < root.right.val:\n        root.right = rotate_right(root.right)\n        return rotate_left(root)\n    \n    return root\n\n# Example usage\nroot = None\nvals = [10, 20, 30, 40, 50, 25]\nfor val in vals:\n    root = insert_avl(root, val)\n\nprint(\"AVL tree created with rotations\")"
  },
  {
    "id": "red-black-tree",
    "name": "Red-Black Tree",
    "description": "Self-balancing BST with color-coded nodes",
    "complexity": { "time": "O(log n) guaranteed", "space": "O(n)" },
    "applications": ["C++ STL map", "Java TreeMap", "Linux kernel"],
    "difficulty": "Advanced",
    "category": "Trees",
    "youtubeUrl": "https://www.youtube.com/watch?v=qvZGUFHWChY",
    "explanation": "A red-black tree is a self-balancing binary search tree where each node has a color attribute (red or black) to ensure the tree remains balanced during insertions and deletions.\n\nKey properties:\n• Nodes are red or black\n• Root is black\n• Red nodes cannot have red children\n• Every path from root to leaf has same number of black nodes\n\nRed-black trees provide efficient balanced search trees used in many libraries and systems.",
    "pythonCode": "class RBNode:\n    def __init__(self, val, color=\"RED\"):\n        self.val = val\n        self.color = color\n        self.left = None\n        self.right = None\n        self.parent = None\n\nclass RedBlackTree:\n    def __init__(self):\n        self.NIL = RBNode(0, \"BLACK\")\n        self.root = self.NIL\n    \n    def left_rotate(self, x):\n        y = x.right\n        x.right = y.left\n        \n        if y.left != self.NIL:\n            y.left.parent = x\n        \n        y.parent = x.parent\n        \n        if x.parent == None:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        \n        y.left = x\n        x.parent = y\n    \n    def right_rotate(self, x):\n        y = x.left\n        x.left = y.right\n        \n        if y.right != self.NIL:\n            y.right.parent = x\n        \n        y.parent = x.parent\n        \n        if x.parent == None:\n            self.root = y\n        elif x == x.parent.right:\n            x.parent.right = y\n        else:\n            x.parent.left = y\n        \n        y.right = x\n        x.parent = y\n    \n    def fix_insert(self, k):\n        while k.parent.color == \"RED\":\n            if k.parent == k.parent.parent.right:\n                u = k.parent.parent.left  # uncle\n                if u.color == \"RED\":\n                    u.color = \"BLACK\"\n                    k.parent.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    k = k.parent.parent\n                else:\n                    if k == k.parent.left:\n                        k = k.parent\n                        self.right_rotate(k)\n                    k.parent.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    self.left_rotate(k.parent.parent)\n            else:\n                u = k.parent.parent.right  # uncle\n                if u.color == \"RED\":\n                    u.color = \"BLACK\"\n                    k.parent.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    k = k.parent.parent\n                else:\n                    if k == k.parent.right:\n                        k = k.parent\n                        self.left_rotate(k)\n                    k.parent.color = \"BLACK\"\n                    k.parent.parent.color = \"RED\"\n                    self.right_rotate(k.parent.parent)\n            \n            if k == self.root:\n                break\n        \n        self.root.color = \"BLACK\"\n\n# Example usage\nrb_tree = RedBlackTree()\nprint(\"Red-Black tree operations implemented\")"
  },
  {
    "id": "b-tree",
    "name": "B-Tree",
    "description": "Self-balancing tree optimized for disk storage",
    "complexity": { "time": "O(log n)", "space": "O(n)" },
    "applications": ["Database indexing", "File systems", "B+ trees"],
    "difficulty": "Advanced",
    "category": "Trees",
    "youtubeUrl": "https://www.youtube.com/watch?v=aZjYr87r1b8",
    "explanation": "A B-tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. It is optimized for systems that read and write large blocks of data.\n\nKey properties:\n• Nodes can have multiple keys and children\n• Balanced height for efficient disk access\n• Used in databases and file systems\n• Supports range queries efficiently\n\nB-trees are essential for large-scale storage systems.",
    "pythonCode": "# B-tree implementation is complex; here is a simplified placeholder\nclass BTreeNode:\n    def __init__(self, t):\n        self.keys = []\n        self.children = []\n        self.leaf = True\n        self.t = t  # Minimum degree\n\nclass BTree:\n    def __init__(self, t):\n        self.root = BTreeNode(t)\n        self.t = t\n\n    # Insert, delete, and search methods would be implemented here\n\n# Example usage\nbtree = BTree(3)\nprint(\"B-tree structure initialized\")"
  },
  {
    "id": "heap",
    "name": "Heap",
    "description": "Complete binary tree with heap property",
    "complexity": { "time": "O(log n) insert", "space": "O(n)" },
    "applications": ["Priority queues", "Heap sort", "Graph algorithms"],
    "difficulty": "Intermediate",
    "category": "Trees",
    "youtubeUrl": "https://www.youtube.com/watch?v=t0Cq6tVNRBA",
    "explanation": "A heap is a specialized tree-based data structure that satisfies the heap property: in a max heap, parent nodes are greater than or equal to their children; in a min heap, they are less.\n\nKey characteristics:\n• Complete binary tree\n• Efficient for priority queue operations\n• Insert and extract-min/max in O(log n)\n• Used in sorting and graph algorithms\n\nHeaps are fundamental in implementing priority queues and efficient sorting.",
    "pythonCode": "import heapq\n\ndef heap_example():\n    heap = []\n    heapq.heappush(heap, 3)\n    heapq.heappush(heap, 1)\n    heapq.heappush(heap, 2)\n    print(heapq.heappop(heap))  # Outputs 1\n\nheap_example()"
  },
  {
    "id": "trie",
    "name": "Trie (Prefix Tree)",
    "description": "Tree for storing strings with common prefixes",
    "complexity": { "time": "O(m) operations", "space": "O(n*m)" },
    "applications": ["Autocomplete", "Spell checkers", "IP routing"],
    "difficulty": "Intermediate",
    "category": "Trees",
    "youtubeUrl": "https://www.youtube.com/watch?v=AXjmTQ8LEoI",
    "explanation": "A trie is a tree-like data structure used to store a dynamic set or associative array where the keys are usually strings. It is efficient for prefix-based searches.\n\nKey characteristics:\n• Nodes represent prefixes of keys\n• Supports fast retrieval of keys with common prefixes\n• Used in autocomplete and spell checking\n• Space complexity depends on number and length of keys\n\nTries are powerful for string processing and retrieval tasks.",
    "pythonCode": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n    \n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n# Example usage\ntrie = Trie()\ntrie.insert(\"hello\")\nprint(trie.search(\"hello\"))  # True\nprint(trie.search(\"hell\"))   # False"
  },
  {
    "id": "segment-tree",
    "name": "Segment Tree",
    "description": "Binary tree for range queries and updates",
    "complexity": { "time": "O(log n)", "space": "O(n)" },
    "applications": ["Range queries", "Lazy propagation", "Geometric algorithms"],
    "difficulty": "Advanced",
    "category": "Trees",
    "youtubeUrl": "https://www.youtube.com/watch?v=ZBHKZF5w4YU",
    "explanation": "A segment tree is a binary tree used for storing intervals or segments. It allows querying which of the stored segments contain a given point efficiently.\n\nKey characteristics:\n• Supports range queries and updates in O(log n)\n• Uses extra space proportional to 4*n\n• Useful in computational geometry and range queries\n• Can be extended with lazy propagation for efficiency\n\nSegment trees are advanced data structures for interval problems.",
    "pythonCode": "class SegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n    \n    def update(self, index, value):\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n    \n    def query(self, left, right):\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left % 2:\n                result += self.tree[left]\n                left += 1\n            if right % 2:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\n# Example usage\ndata = [1, 3, 5, 7, 9, 11]\nseg_tree = SegmentTree(data)\nprint(seg_tree.query(1, 5))  # Outputs sum from index 1 to 4"
  },
  {
    "id": "fenwick-tree",
    "name": "Fenwick Tree (BIT)",
    "description": "Binary tree for prefix sum queries",
    "complexity": { "time": "O(log n)", "space": "O(n)" },
    "applications": ["Prefix sums", "Frequency tables", "Inversion counting"],
    "difficulty": "Advanced",
    "category": "Trees",
    "youtubeUrl": "https://www.youtube.com/watch?v=CWDQJGaN1gY",
    "explanation": "A Fenwick tree or Binary Indexed Tree (BIT) is a data structure that provides efficient methods for calculation and manipulation of the prefix sums of a table of values.\n\nKey characteristics:\n• Supports prefix sum and update in O(log n)\n• Uses an array-based tree structure\n• Useful in frequency counting and inversion problems\n• More space efficient than segment trees\n\nFenwick trees are widely used in competitive programming and data analysis.",
    "pythonCode": "class FenwickTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (size + 1)\n    \n    def update(self, index, value):\n        while index <= self.size:\n            self.tree[index] += value\n            index += index & (-index)\n    \n    def query(self, index):\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & (-index)\n        return result\n\n# Example usage\nft = FenwickTree(5)\nft.update(1, 2)\nft.update(3, 5)\nprint(ft.query(3))  # Outputs prefix sum up to index 3"
  },
  {
    "id": "graph",
    "name": "Graph",
    "description": "Collection of vertices connected by edges",
    "complexity": { "time": "O(V+E)", "space": "O(V+E)" },
    "applications": ["Social networks", "GPS navigation", "Web crawling"],
    "difficulty": "Intermediate",
    "category": "Graphs",
    "youtubeUrl": "https://www.youtube.com/watch?v=gXgEDyodOJU",
    "explanation": "A graph is a collection of nodes (vertices) connected by edges. Graphs can be directed or undirected and are used to model pairwise relations.\n\nKey characteristics:\n• Vertices and edges\n• Can be weighted or unweighted\n• Represented using adjacency lists or matrices\n• Used in networking, social media, and pathfinding\n\nGraphs are fundamental in computer science and many real-world applications.",
    "pythonCode": "class Graph:\n    def __init__(self):\n        self.adj_list = {}\n    \n    def add_edge(self, u, v):\n        if u not in self.adj_list:\n            self.adj_list[u] = []\n        self.adj_list[u].append(v)\n    \n    def print_graph(self):\n        for vertex in self.adj_list:\n            print(f\"{vertex}: {self.adj_list[vertex]}\")\n\n# Example usage\ng = Graph()\ng.add_edge('A', 'B')\ng.add_edge('A', 'C')\ng.print_graph()"
  },
  {
    "id": "directed-graph",
    "name": "Directed Graph",
    "description": "Graph where edges have a specific direction",
    "complexity": { "time": "O(V+E)", "space": "O(V+E)" },
    "applications": ["Web page linking", "Task dependencies", "Citation networks"],
    "difficulty": "Intermediate",
    "category": "Graphs",
    "youtubeUrl": "https://www.youtube.com/watch?v=AfYqN3fGapc",
    "explanation": "A directed graph (digraph) is a graph where edges have a direction, going from one vertex to another.\n\nKey characteristics:\n• Edges have direction\n• Used to model asymmetric relationships\n• Represented with adjacency lists or matrices\n• Used in task scheduling, web graphs, and more\n\nDirected graphs are essential for modeling dependencies and flows.",
    "pythonCode": "class DirectedGraph:\n    def __init__(self):\n        self.adj_list = {}\n    \n    def add_edge(self, u, v):\n        if u not in self.adj_list:\n            self.adj_list[u] = []\n        self.adj_list[u].append(v)\n    \n    def print_graph(self):\n        for vertex in self.adj_list:\n            print(f\"{vertex} -> {self.adj_list[vertex]}\")\n\n# Example usage\ndg = DirectedGraph()\ndg.add_edge('A', 'B')\ndg.add_edge('B', 'C')\ndg.print_graph()"
  },
  {
    "id": "weighted-graph",
    "name": "Weighted Graph",
    "description": "Graph with weights assigned to edges",
    "complexity": { "time": "O(V+E)", "space": "O(V+E)" },
    "applications": ["Shortest path", "Network routing", "Flight connections"],
    "difficulty": "Intermediate",
    "category": "Graphs",
    "youtubeUrl": "https://www.youtube.com/watch?v=pVfj6mxhdMw",
    "explanation": "A weighted graph is a graph where each edge has an associated weight or cost.\n\nKey characteristics:\n• Edges have weights\n• Used in shortest path and network flow problems\n• Represented with adjacency lists including weights\n• Supports algorithms like Dijkstra and Bellman-Ford\n\nWeighted graphs model real-world networks with costs or distances.",
    "pythonCode": "class WeightedGraph:\n    def __init__(self):\n        self.adj_list = {}\n    \n    def add_edge(self, u, v, weight):\n        if u not in self.adj_list:\n            self.adj_list[u] = []\n        self.adj_list[u].append((v, weight))\n    \n    def print_graph(self):\n        for vertex in self.adj_list:\n            print(f\"{vertex}: {self.adj_list[vertex]}\")\n\n# Example usage\nwg = WeightedGraph()\nwg.add_edge('A', 'B', 5)\nwg.add_edge('B', 'C', 3)\nwg.print_graph()"
  },
  {
    "id": "adjacency-matrix",
    "name": "Adjacency Matrix",
    "description": "2D array representation of graph connections",
    "complexity": { "time": "O(1) edge check", "space": "O(V²)" },
    "applications": ["Dense graphs", "Matrix algorithms", "Quick edge lookup"],
    "difficulty": "Beginner",
    "category": "Graphs",
    "youtubeUrl": "https://www.youtube.com/watch?v=9C2cpQZVRBA",
    "explanation": "An adjacency matrix is a 2D array used to represent a graph, where each cell indicates the presence or weight of an edge between vertices.\n\nKey characteristics:\n• Uses O(V²) space\n• Fast edge existence check in O(1)\n• Suitable for dense graphs\n• Simple to implement\n\nAdjacency matrices are useful for algorithms requiring quick edge lookups.",
    "pythonCode": "def create_adjacency_matrix(vertices, edges):\n    size = len(vertices)\n    matrix = [[0] * size for _ in range(size)]\n    vertex_index = {v: i for i, v in enumerate(vertices)}\n    \n    for u, v in edges:\n        i, j = vertex_index[u], vertex_index[v]\n        matrix[i][j] = 1  # or weight if weighted\n    \n    return matrix\n\n# Example usage\nvertices = ['A', 'B', 'C']\nedges = [('A', 'B'), ('B', 'C')]\nmatrix = create_adjacency_matrix(vertices, edges)\nprint(matrix)"
  },
  {
    "id": "adjacency-list",
    "name": "Adjacency List",
    "description": "List-based representation of graph connections",
    "complexity": { "time": "O(V) edge check", "space": "O(V+E)" },
    "applications": ["Sparse graphs", "Graph traversal", "Memory efficiency"],
    "difficulty": "Beginner",
    "category": "Graphs",
    "youtubeUrl": "https://www.youtube.com/watch?v=k1wraWzqtvQ",
    "explanation": "An adjacency list represents a graph as an array or list of lists, where each list contains the neighbors of a vertex.\n\nKey characteristics:\n• Uses O(V+E) space\n• Efficient for sparse graphs\n• Easy to iterate over neighbors\n• Commonly used in graph algorithms\n\nAdjacency lists are the preferred representation for most graph problems.",
    "pythonCode": "def create_adjacency_list(vertices, edges):\n    adj_list = {v: [] for v in vertices}\n    for u, v in edges:\n        adj_list[u].append(v)\n    return adj_list\n\n# Example usage\nvertices = ['A', 'B', 'C']\nedges = [('A', 'B'), ('B', 'C')]\nadj_list = create_adjacency_list(vertices, edges)\nprint(adj_list)"
  },
  {
    "id": "bipartite-graph",
    "name": "Bipartite Graph",
    "description": "Graph whose vertices can be divided into two disjoint sets",
    "complexity": { "time": "O(V+E)", "space": "O(V)" },
    "applications": ["Matching problems", "Job assignments", "Recommendation systems"],
    "difficulty": "Advanced",
    "category": "Graphs",
    "youtubeUrl": "https://www.youtube.com/watch?v=ySSdNhpzOPE",
    "explanation": "A bipartite graph is a graph whose vertices can be divided into two disjoint sets such that every edge connects a vertex from one set to the other.\n\nKey characteristics:\n• No edges between vertices of the same set\n• Used in matching and assignment problems\n• Can be checked using BFS or DFS\n• Important in network flow and scheduling\n\nBipartite graphs model relationships between two distinct groups.",
    "pythonCode": "from collections import deque\n\ndef is_bipartite(graph):\n    color = {}\n    for node in graph:\n        if node not in color:\n            queue = deque([node])\n            color[node] = 0\n            while queue:\n                u = queue.popleft()\n                for v in graph[u]:\n                    if v not in color:\n                        color[v] = 1 - color[u]\n                        queue.append(v)\n                    elif color[v] == color[u]:\n                        return False\n    return True\n\n# Example usage\ngraph = {\n    0: [1, 3],\n    1: [0, 2],\n    2: [1, 3],\n    3: [0, 2]\n}\nprint(is_bipartite(graph))  # True"
  },
  {
    "id": "dag",
    "name": "Directed Acyclic Graph (DAG)",
    "description": "Directed graph with no cycles",
    "complexity": { "time": "O(V+E)", "space": "O(V)" },
    "applications": ["Task scheduling", "Dependency resolution", "Compiler design"],
    "difficulty": "Advanced",
    "category": "Graphs",
    "youtubeUrl": "https://www.youtube.com/watch?v=ZeDNSeilf-Y",
    "explanation": "A DAG is a directed graph with no directed cycles. It is used to represent dependencies and ordering.\n\nKey characteristics:\n• Directed edges with no cycles\n• Supports topological sorting\n• Used in scheduling and data processing\n• Important in compiler optimizations\n\nDAGs model workflows and dependencies efficiently.",
    "pythonCode": "from collections import defaultdict\n\ndef topological_sort(vertices, edges):\n    graph = defaultdict(list)\n    in_degree = {v: 0 for v in vertices}\n    \n    for u, v in edges:\n        graph[u].append(v)\n        in_degree[v] += 1\n    \n    queue = [v for v in vertices if in_degree[v] == 0]\n    topo_order = []\n    \n    while queue:\n        u = queue.pop(0)\n        topo_order.append(u)\n        for v in graph[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    \n    if len(topo_order) == len(vertices):\n        return topo_order\n    else:\n        return None  # Cycle detected\n\n# Example usage\nvertices = ['A', 'B', 'C', 'D']\nedges = [('A', 'B'), ('B', 'C'), ('A', 'C'), ('C', 'D')]\nprint(topological_sort(vertices, edges))"
  },
  {
    "id": "hash-table",
    "name": "Hash Table",
    "description": "Data structure that maps keys to values using hash function",
    "complexity": { "time": "O(1) average", "space": "O(n)" },
    "applications": ["Dictionaries", "Caching", "Database indexing"],
    "difficulty": "Intermediate",
    "category": "Hash Tables",
    "youtubeUrl": "https://www.youtube.com/watch?v=shs0KM3wKv8",
    "explanation": "A hash table is a data structure that implements an associative array abstract data type, a structure that can map keys to values using a hash function.\n\nKey characteristics:\n• Provides average O(1) time for search, insert, delete\n• Uses hash functions to compute index\n• Handles collisions via chaining or open addressing\n• Widely used in databases and caches\n\nHash tables are fundamental for fast data retrieval.",
    "pythonCode": "# Python dict is a hash table\ndef hash_table_example():\n    ht = {}\n    ht['apple'] = 1\n    ht['banana'] = 2\n    print(ht['apple'])  # Outputs 1\n\nhash_table_example()"
  },
  {
    "id": "hash-map",
    "name": "Hash Map",
    "description": "Implementation of hash table with key-value pairs",
    "complexity": { "time": "O(1) average", "space": "O(n)" },
    "applications": ["Caching", "Frequency counting", "Fast lookups"],
    "difficulty": "Intermediate",
    "category": "Hash Tables",
    "youtubeUrl": "https://www.youtube.com/watch?v=h2d9b_nEzoA",
    "explanation": "A hash map is a hash table implementation that stores key-value pairs, allowing efficient lookup, insertion, and deletion.\n\nKey characteristics:\n• Maps keys to values\n• Uses hashing for indexing\n• Handles collisions effectively\n• Used in caching and frequency analysis\n\nHash maps are core to many programming language libraries.",
    "pythonCode": "class HashMap:\n    def __init__(self):\n        self.size = 10\n        self.map = [[] for _ in range(self.size)]\n    \n    def _get_hash(self, key):\n        return hash(key) % self.size\n    \n    def add(self, key, value):\n        key_hash = self._get_hash(key)\n        key_exists = False\n        bucket = self.map[key_hash]\n        for i, kv in enumerate(bucket):\n            k, v = kv\n            if k == key:\n                bucket[i] = (key, value)\n                key_exists = True\n                break\n        if not key_exists:\n            bucket.append((key, value))\n    \n    def get(self, key):\n        key_hash = self._get_hash(key)\n        bucket = self.map[key_hash]\n        for k, v in bucket:\n            if k == key:\n                return v\n        return None\n\n# Example usage\nhm = HashMap()\nhm.add('apple', 10)\nprint(hm.get('apple'))  # Outputs 10"
  },
  {
    "id": "hash-set",
    "name": "Hash Set",
    "description": "Set implementation using hash table for unique elements",
    "complexity": { "time": "O(1) average", "space": "O(n)" },
    "applications": ["Duplicate detection", "Set operations", "Membership testing"],
    "difficulty": "Intermediate",
    "category": "Hash Tables",
    "youtubeUrl": "https://www.youtube.com/watch?v=WmOQdFMy51c",
    "explanation": "A hash set is a set data structure implemented using a hash table to store unique elements with efficient insertion, deletion, and membership testing.\n\nKey characteristics:\n• Stores unique elements\n• Uses hashing for fast operations\n• Supports union, intersection, difference\n• Used in duplicate detection and membership queries\n\nHash sets are widely used in data processing and algorithms.",
    "pythonCode": "# Python set is a hash set\ndef hash_set_example():\n    hs = set()\n    hs.add(1)\n    hs.add(2)\n    hs.add(1)  # Duplicate ignored\n    print(hs)  # Outputs {1, 2}\n\nhash_set_example()"
  },
  {
    "id": "consistent-hashing",
    "name": "Consistent Hashing",
    "description": "Hash technique for distributed systems",
    "complexity": { "time": "O(log n)", "space": "O(n)" },
    "applications": ["Load balancing", "Distributed caching", "Database sharding"],
    "difficulty": "Advanced",
    "category": "Hash Tables",
    "youtubeUrl": "https://www.youtube.com/watch?v=zaRkONvyGr8",
    "explanation": "Consistent hashing is a hashing scheme that operates independently of the number of servers or objects in a distributed hash table, minimizing remapping when nodes change.\n\nKey characteristics:\n• Minimizes key remapping on node changes\n• Uses a hash ring to assign keys to nodes\n• Used in distributed caching and load balancing\n• Improves scalability and fault tolerance\n\nConsistent hashing is critical in distributed system design.",
    "pythonCode": "# Simplified consistent hashing example\nimport bisect\nimport hashlib\n\nclass ConsistentHashRing:\n    def __init__(self, nodes=None, replicas=3):\n        self.replicas = replicas\n        self.ring = []\n        self.nodes = {}\n        if nodes:\n            for node in nodes:\n                self.add_node(node)\n    \n    def _hash(self, key):\n        return int(hashlib.md5(key.encode()).hexdigest(), 16)\n    \n    def add_node(self, node):\n        for i in range(self.replicas):\n            key = f\"{node}:{i}\"\n            h = self._hash(key)\n            self.ring.insert(bisect.bisect(self.ring, h), h)\n            self.nodes[h] = node\n    \n    def get_node(self, key):\n        h = self._hash(key)\n        idx = bisect.bisect(self.ring, h) % len(self.ring)\n        return self.nodes[self.ring[idx]]\n\n# Example usage\nring = ConsistentHashRing(['node1', 'node2', 'node3'])\nprint(ring.get_node('my_key'))"
  },
  {
    "id": "bloom-filter",
    "name": "Bloom Filter",
    "description": "Probabilistic data structure for membership testing",
    "complexity": { "time": "O(k)", "space": "O(m)" },
    "applications": ["Web caching", "Database queries", "Spam filtering"],
    "difficulty": "Advanced",
    "category": "Hash Tables",
    "youtubeUrl": "https://www.youtube.com/watch?v=Bay3X9PAX5k",
    "explanation": "A Bloom filter is a space-efficient probabilistic data structure used to test whether an element is a member of a set, allowing false positives but no false negatives.\n\nKey characteristics:\n• Uses multiple hash functions\n• Space efficient with trade-off in accuracy\n• Used in caching and network systems\n• Supports insert and membership queries\n\nBloom filters are useful for large-scale membership testing.",
    "pythonCode": "import mmh3\nfrom bitarray import bitarray\n\nclass BloomFilter:\n    def __init__(self, size, hash_count):\n        self.size = size\n        self.hash_count = hash_count\n        self.bit_array = bitarray(size)\n        self.bit_array.setall(0)\n    \n    def add(self, item):\n        for i in range(self.hash_count):\n            digest = mmh3.hash(item, i) % self.size\n            self.bit_array[digest] = 1\n    \n    def check(self, item):\n        for i in range(self.hash_count):\n            digest = mmh3.hash(item, i) % self.size\n            if self.bit_array[digest] == 0:\n                return False\n        return True\n\n# Example usage\nbf = BloomFilter(5000, 7)\nbf.add(\"apple\")\nprint(bf.check(\"apple\"))  # True\nprint(bf.check(\"banana\")) # False (probably)"
  },
  {
    "id": "cuckoo-hashing",
    "name": "Cuckoo Hashing",
    "description": "Hashing scheme guaranteeing O(1) lookup time",
    "complexity": { "time": "O(1) worst case", "space": "O(n)" },
    "applications": ["Real-time systems", "Hardware implementation", "Network switches"],
    "difficulty": "Advanced",
    "category": "Hash Tables",
    "youtubeUrl": "https://www.youtube.com/watch?v=R3JOj7aYYnQ",
    "explanation": "Cuckoo hashing is a scheme in computer programming for resolving hash collisions of values of hash functions in a table, guaranteeing constant worst-case lookup time.\n\nKey characteristics:\n• Uses two hash functions and two tables\n• On collision, displaces existing keys\n• Guarantees O(1) worst-case lookup\n• Used in high-performance and hardware systems\n\nCuckoo hashing is important for real-time and low-latency applications.",
    "pythonCode": "class CuckooHashTable:\n    def __init__(self, size):\n        self.size = size\n        self.table1 = [None] * size\n        self.table2 = [None] * size\n    \n    def hash1(self, key):\n        return hash(key) % self.size\n    \n    def hash2(self, key):\n        return (hash(key) // self.size) % self.size\n    \n    def insert(self, key):\n        pos1 = self.hash1(key)\n        if self.table1[pos1] is None:\n            self.table1[pos1] = key\n            return\n        pos2 = self.hash2(key)\n        if self.table2[pos2] is None:\n            self.table2[pos2] = key\n            return\n        # Evict and reinsert logic omitted for brevity\n\n# Example usage\ncht = CuckooHashTable(11)\ncht.insert(\"apple\")\nprint(cht.table1)\nprint(cht.table2)"
  },
  {
    "id": "skip-list",
    "name": "Skip List",
    "description": "Probabilistic data structure for sorted elements with fast search",
    "complexity": { "time": "O(log n) average", "space": "O(n)" },
    "applications": ["Database indexing", "Concurrent data structures", "Search optimization"],
    "difficulty": "Advanced",
    "category": "Lists",
    "youtubeUrl": "https://www.youtube.com/watch?v=2Ti5kE_Kr8M",
    "explanation": "A skip list is a probabilistic data structure that allows fast search, insertion, and deletion within a sorted list of elements. It uses multiple layers of linked lists with random level assignments.\n\nKey characteristics:\n• Probabilistic alternative to balanced trees\n• Average O(log n) for search, insert, delete\n• Simpler to implement than AVL or Red-Black trees\n• Used in concurrent programming and databases\n\nSkip lists are efficient for dynamic sorted data with simpler balancing.",
    "pythonCode": "import random\n\nclass SkipNode:\n    def __init__(self, value, level):\n        self.value = value\n        self.forward = [None] * (level + 1)\n\nclass SkipList:\n    def __init__(self, max_level):\n        self.max_level = max_level\n        self.head = SkipNode(None, max_level)\n        self.level = 0\n    \n    def random_level(self):\n        level = 0\n        while random.random() < 0.5 and level < self.max_level:\n            level += 1\n        return level\n    \n    def insert(self, value):\n        update = [None] * (self.max_level + 1)\n        current = self.head\n        \n        for i in range(self.level, -1, -1):\n            while current.forward[i] and current.forward[i].value < value:\n                current = current.forward[i]\n            update[i] = current\n        \n        level = self.random_level()\n        if level > self.level:\n            for i in range(self.level + 1, level + 1):\n                update[i] = self.head\n            self.level = level\n        \n        new_node = SkipNode(value, level)\n        for i in range(level + 1):\n            new_node.forward[i] = update[i].forward[i]\n            update[i].forward[i] = new_node\n\n# Example usage\nsl = SkipList(3)\nsl.insert(3)\nsl.insert(6)\nsl.insert(7)\nprint(\"Skip list created with values 3, 6, 7\")"
  },
  {
    "id": "union-find",
    "name": "Union-Find (Disjoint Set)",
    "description": "Data structure for tracking disjoint sets and merging them",
    "complexity": { "time": "O(α(n)) amortized", "space": "O(n)" },
    "applications": ["Kruskal's algorithm", "Connected components", "Graph partitioning"],
    "difficulty": "Advanced",
    "category": "Graphs",
    "youtubeUrl": "https://www.youtube.com/watch?v=ibjEggNived",
    "explanation": "A Union-Find (or Disjoint Set) data structure efficiently tracks a partition of elements into disjoint subsets and supports merging sets and checking connectivity.\n\nKey characteristics:\n• Near-constant time operations with path compression\n• Used in graph algorithms like Kruskal's MST\n• Supports union and find operations\n• Efficient for dynamic connectivity problems\n\nUnion-Find is critical for graph algorithms and network analysis.",
    "pythonCode": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])  # Path compression\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n    \n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n# Example usage\nuf = UnionFind(5)\nuf.union(0, 1)\nuf.union(1, 2)\nprint(uf.connected(0, 2))  # True\nprint(uf.connected(0, 3))  # False"
  },
  {
    "id": "suffix-tree",
    "name": "Suffix Tree",
    "description": "Compressed trie of all suffixes of a string",
    "complexity": { "time": "O(n) build", "space": "O(n)" },
    "applications": ["String matching", "Pattern searching", "Bioinformatics"],
    "difficulty": "Advanced",
    "category": "Trees",
    "youtubeUrl": "https://www.youtube.com/watch?v=Haj6KHa9Dl8",
    "explanation": "A suffix tree is a compressed trie containing all the suffixes of a given string. It is used for efficient string matching and searching.\n\nKey characteristics:\n• Stores all suffixes in a compressed trie\n• Enables fast pattern matching in O(m) time\n• Used in bioinformatics and text processing\n• Requires careful implementation for efficiency\n\nSuffix trees are powerful for string-related algorithms.",
    "pythonCode": "# Simplified suffix tree placeholder (full implementation is complex)\nclass SuffixTreeNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass SuffixTree:\n    def __init__(self):\n        self.root = SuffixTreeNode()\n    \n    def insert(self, suffix):\n        node = self.root\n        for char in suffix:\n            if char not in node.children:\n                node.children[char] = SuffixTreeNode()\n            node = node.children[char]\n        node.is_end = True\n\n# Example usage\nst = SuffixTree()\ntext = \"banana\"\nfor i in range(len(text)):\n    st.insert(text[i:])\nprint(\"Suffix tree created for 'banana'\")"
  },
  {
    "id": "monotonic-stack",
    "name": "Monotonic Stack",
    "description": "Stack maintaining elements in monotonic order (increasing or decreasing)",
    "complexity": { "time": "O(n) processing", "space": "O(n)" },
    "applications": ["Next greater element", "Histogram problems", "Stock span"],
    "difficulty": "Intermediate",
    "category": "Stacks",
    "youtubeUrl": "https://www.youtube.com/watch?v=3jKhM0IPnK8",
    "explanation": "A monotonic stack is a stack where elements are maintained in a strictly increasing or decreasing order as they are pushed. It is used to solve problems involving finding the next or previous greater/smaller element.\n\nKey characteristics:\n• Elements are popped to maintain monotonicity\n• Useful for linear-time solutions to range-based problems\n• Commonly applied in array and histogram problems\n• Efficient for problems requiring relative ordering\n\nMonotonic stacks are powerful in competitive programming and algorithmic challenges.",
    "pythonCode": "def next_greater_element(nums):\n    stack = []\n    result = [-1] * len(nums)\n    \n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            result[stack.pop()] = nums[i]\n        stack.append(i)\n    \n    return result\n\n# Example usage\nnums = [1, 3, 2, 4]\nprint(next_greater_element(nums))  # Outputs [3, 4, 4, -1]"
  },
  {
    "id": "two-stack-queue",
    "name": "Two-Stack Queue",
    "description": "Queue implemented using two stacks",
    "complexity": { "time": "O(1) enqueue, O(n) dequeue", "space": "O(n)" },
    "applications": ["Queue simulation", "Algorithm design", "Data buffering"],
    "difficulty": "Intermediate",
    "category": "Stacks",
    "youtubeUrl": "https://www.youtube.com/watch?v=3XzVqP5OAt8",
    "explanation": "A two-stack queue is a queue implemented using two stacks, where one stack handles enqueue operations and the other handles dequeue operations.\n\nKey characteristics:\n• Enqueue is O(1), dequeue can be O(n) due to stack transfer\n• Simulates FIFO behavior using LIFO structures\n• Useful for understanding stack-based data structure design\n• Applied in scenarios requiring queue functionality with stack primitives\n\nTwo-stack queues demonstrate creative use of stacks for queue operations.",
    "pythonCode": "class TwoStackQueue:\n    def __init__(self):\n        self.stack1 = []  # For enqueue\n        self.stack2 = []  # For dequeue\n    \n    def enqueue(self, item):\n        self.stack1.append(item)\n    \n    def dequeue(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        if self.stack2:\n            return self.stack2.pop()\n        return None\n\n# Example usage\nqueue = TwoStackQueue()\nqueue.enqueue(1)\nqueue.enqueue(2)\nprint(queue.dequeue())  # Outputs 1\nqueue.enqueue(3)\nprint(queue.dequeue())  # Outputs 2"
  },
  {
    "id": "expression-stack",
    "name": "Expression Stack",
    "description": "Stack for evaluating or converting arithmetic expressions",
    "complexity": { "time": "O(n) evaluation", "space": "O(n)" },
    "applications": ["Expression parsing", "Calculator programs", "Compiler design"],
    "difficulty": "Intermediate",
    "category": "Stacks",
    "youtubeUrl": "https://www.youtube.com/watch?v=MeRb_1bddWg",
    "explanation": "An expression stack is a stack used to evaluate arithmetic expressions (e.g., infix, postfix) or convert between expression notations (e.g., infix to postfix).\n\nKey characteristics:\n• Processes operators and operands in order\n• Handles parentheses and operator precedence\n• Used in compilers and calculators\n• Enables efficient expression evaluation in O(n) time\n\nExpression stacks are essential for parsing and evaluating mathematical expressions.",
    "pythonCode": "def evaluate_postfix(expression):\n    stack = []\n    for token in expression.split():\n        if token in '+-*/':\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+': stack.append(a + b)\n            elif token == '-': stack.append(a - b)\n            elif token == '*': stack.append(a * b)\n            elif token == '/': stack.append(a / b)\n        else:\n            stack.append(float(token))\n    return stack[0]\n\n# Example usage\npostfix = \"2 3 * 4 +\"\nprint(evaluate_postfix(postfix))  # Outputs 10.0 (2 * 3 + 4)"
  },
  {
    "id": "xor-linked-list",
    "name": "XOR Linked List",
    "description": "Memory-efficient doubly linked list using XOR operations",
    "complexity": { "time": "O(n) traversal", "space": "O(n)" },
    "applications": ["Memory-constrained systems", "Embedded systems", "Data compression"],
    "difficulty": "Advanced",
    "category": "Lists",
    "youtubeUrl": "https://www.youtube.com/watch?v=6sBhQcpjAXw",
    "explanation": "An XOR linked list is a memory-efficient doubly linked list where each node stores a single pointer that is the XOR of the next and previous node addresses. It allows bidirectional traversal with reduced memory usage.\n\nKey characteristics:\n• Uses XOR operations to store pointers\n• Saves memory compared to standard doubly linked lists\n• Requires careful pointer arithmetic\n• Used in memory-constrained environments\n\nXOR linked lists are an advanced optimization for memory efficiency.",
    "pythonCode": "# XOR Linked List (simplified, Python doesn't support raw pointers)\n# Conceptual implementation\nclass XORNode:\n    def __init__(self, data):\n        self.data = data\n        self.both = id(None)  # Simulating XOR pointer\n\nclass XORLinkedList:\n    def __init__(self):\n        self.head = None\n        self.nodes = []  # To simulate memory addresses\n    \n    def add(self, data):\n        node = XORNode(data)\n        self.nodes.append(node)  # Store for reference\n        if not self.head:\n            self.head = node\n        # Actual XOR pointer logic requires raw memory access\n\n# Example usage\nxor_list = XORLinkedList()\nxor_list.add(1)\nxor_list.add(2)\nprint(\"XOR Linked List initialized (simulated)\")"
  },
  {
    "id": "unrolled-linked-list",
    "name": "Unrolled Linked List",
    "description": "Linked list where nodes store arrays of elements",
    "complexity": { "time": "O(√n) search", "space": "O(n)" },
    "applications": ["Cache efficiency", "Database storage", "Big data processing"],
    "difficulty": "Advanced",
    "category": "Lists",
    "youtubeUrl": "https://www.youtube.com/watch?v=2A5Z4iAB2PI",
    "explanation": "An unrolled linked list is a linked list where each node contains an array of elements instead of a single element, improving cache efficiency and reducing pointer overhead.\n\nKey characteristics:\n• Nodes store fixed-size arrays\n• Reduces memory overhead of pointers\n• Improves cache locality and performance\n• Used in systems requiring efficient sequential access\n\nUnrolled linked lists optimize performance for large datasets.",
    "pythonCode": "class UnrolledNode:\n    def __init__(self, capacity):\n        self.elements = []\n        self.capacity = capacity\n        self.next = None\n\nclass UnrolledLinkedList:\n    def __init__(self, capacity=4):\n        self.head = None\n        self.capacity = capacity\n    \n    def insert(self, value):\n        if not self.head or len(self.head.elements) == self.capacity:\n            new_node = UnrolledNode(self.capacity)\n            new_node.next = self.head\n            self.head = new_node\n        self.head.elements.append(value)\n    \n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.elements, end=' -> ')\n            current = current.next\n        print('None')\n\n# Example usage\null = UnrolledLinkedList(3)\nfor i in range(1, 7):\n    ull.insert(i)\null.print_list()  # Outputs [4, 5, 6] -> [1, 2, 3] -> None"
  }
]